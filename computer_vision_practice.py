# -*- coding: utf-8 -*-
"""Computer Vision Practice.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ae2iR7UmMiYc16ZGd4lQQuBFi_QJoxR-
"""

!wget --no-check-certificate \
    https://github.com/btphan95/simple-cnn/blob/master/train.zip?raw=true \
    -O /tmp/train.zip

!wget --no-check-certificate \
    https://github.com/btphan95/simple-cnn/blob/master/valid.zip?raw=true \
    -O /tmp/valid.zip

#unzipping data
import os
import zipfile as zip

local_zip = '/tmp/train.zip'
zip_ref = zip.ZipFile(local_zip,'r')
zip_ref.extractall('/tmp')
local_zip = '/tmp/valid.zip'
zip_ref = zip.ZipFile(local_zip,'r')
zip_ref.extractall('/tmp')
zip_ref.close()

#establish directories for two classes
train_dandelion_dir = os.path.join('/tmp/train/dandelion')
train_grass_dir = os.path.join('/tmp/train/grass')
valid_dandelion_dir = os.path.join('/tmp/valid/dandelion')
valid_grass_dir = os.path.join('/tmp/valid/grass')

#checking file names 
train_dandelion_names = os.listdir(train_dandelion_dir)

train_grass_names = os.listdir(train_grass_dir)

valid_grass_names = os.listdir(valid_grass_dir)

valid_dandelion_names = os.listdir(valid_dandelion_dir)

#checking file counts
print('Total # of dandelion images in train dataset:',len(os.listdir(train_dandelion_dir)))
print('Total # of grass images in train dataset:',len(os.listdir(train_grass_dir)))
print('Total # of valid dandelion images:',len(os.listdir(valid_dandelion_dir)))
print('Total # of valid grass images:',len(os.listdir(valid_grass_dir)))

# Commented out IPython magic to ensure Python compatibility.
#taking a look at some of the images provided
# %matplotlib inline

import matplotlib.pyplot as plt
import matplotlib.image as mpimg

#checking a 4x4 plot of 16 images
ncols = 4
nrows = 4
#iterating over images
pic_index = 0

fig = plt.gcf()
fig.set_size_inches(ncols * 4, nrows*4)

pic_index += 8

next_dand_pic = [os.path.join(train_dandelion_dir,fname)
              for fname in train_dandelion_names[pic_index-8:pic_index]]
next_grass_pic = [os.path.join(train_grass_dir,fname)
              for fname in train_grass_names[pic_index-8:pic_index]]

for i, img_path in enumerate(next_dand_pic + next_grass_pic):
  #setting subplot with image indices starting at one
  sp = plt.subplot(nrows, ncols, i +1)
  #turning off gridlines
  sp.axis('Off')

  img = mpimg.imread(img_path)
  plt.imshow(img)

plt.show()

#performing some preprocessing with keras 
#attempting to normalize data and place it into training and validation sets
from tensorflow.keras.preprocessing.image import ImageDataGenerator as IDG

#re-scale
train_datagen = IDG(rescale=1/255)
valid_datagen = IDG(rescale=1/255)

#batches of 120 flow for train
train_generator = train_datagen.flow_from_directory('/tmp/train/',
                                                    classes = ['dandelion','grass'],
                                                    target_size = (200,200),batch_size=120,
                                                    class_mode='binary')
#batches of 19 flow for valid
valid_generator = valid_datagen.flow_from_directory('/tmp/valid/', 
                                                    classes = ['dandelion','grass'],
                                                    target_size=(200,200),
                                                    batch_size = 19, 
                                                    class_mode = 'binary',
                                                    shuffle=False)

"""Going to try and build the model from scratch"""

#importing tools 
import tensorflow as tf
import numpy as np
from itertools import cycle

from scipy import interp

from sklearn import svm, datasets
from sklearn.metrics import roc_curve, f1_score, auc, accuracy_score, roc_auc_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import label_binarize
from sklearn.multiclass import OneVsRestClassifier

#building 2 layer seuential model with 128 hidden units and sigmoid final layer (since it's bianary classification). Going to flatten images first.
model = tf.keras.Sequential([tf.keras.layers.Flatten(input_shape = (200,200,3)),
                             tf.keras.layers.Dense(128,activation = tf.nn.relu),
                             tf.keras.layers.Dense(1,activation = tf.nn.sigmoid)])

model.summary()

#compile model, using adam as optimiation alorithm because it will automate the learning tuning
model.compile(optimizer = tf.optimizers.Adam(),
              loss='binary_crossentropy',
              metrics=['accuracy'])

#Training model for 15 epochs using 960 of the available images
history = model.fit(train_generator, steps_per_epoch = 8, 
                    epochs = 15, 
                    verbose = 1, 
                    validation_data = valid_generator, 
                    validation_steps = 8)

#evaluating model in terms of accuracy
model.evaluate(valid_generator)

#making predictions on validation set
stepsize_test = valid_generator.n//valid_generator.batch_size
valid_generator.reset()

first_predictions = model.predict(valid_generator,verbose = 0)

# creating roc curve

false_pos, true_pos, _ = roc_curve(valid_generator.classes, first_predictions)
roc_auc = auc(false_pos,true_pos)

plt.figure()
lw = 2
plt.plot(false_pos, true_pos, color = 'red', lw=lw, label = 'ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0,1],[0,1], color = 'black', lw = lw, linestyle = ':')
plt.xlim([0.0,1.05])
plt.ylim([0.0,1.05])
plt.xlabel('False Positive Rate')
plt.title('Receiver Operator Characteristic')
plt.ylabel('True Positive Rate')
plt.legend(loc='lower right')
plt.show()

#trying it out on uploaded files! If testing your own upload just press the run button again and it should give you the opportunity to choose your own file.

from google.colab import files
import tensorflow.keras.preprocessing.image as image
uploaded = files.upload()

for fn in uploaded.keys():

  path = '/content/' + fn 
  img = image.load_img(path, target_size=(200,200))
  x = image.img_to_array(img)
  plt.imshow(x/255)
  x = np.expand_dims(x,axis=0)
  images= np.vstack([x])
  classes = model.predict(images, batch_size = 10)
  import numpy as numpy
  if classes[0]<.5:
    print(fn + 'is a dandelion')
  else :
    print(fn + ' is grass')